<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Baguette Splitter</title>
  <style>
    :root {
      --bg: #0f1220;
      --fg: #e7e9ee;
      --accent: #8dd7ff;
      --accent2: #ffc36b;
      --danger: #ff6b6b;
      --panel: #171a2b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 50% -200px, #1a1e34 0%, var(--bg) 60%);
      color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      display: grid; place-items: center; overflow: hidden;
    }
    #wrap { position: relative; width: min(100vw, 980px); aspect-ratio: 16 / 9; }
    canvas { width: 100%; height: 100%; display: block; border-radius: 18px; box-shadow: 0 20px 60px rgba(0,0,0,.45); background: linear-gradient(180deg, #101427, #0b0e1c 80%); }

    .hud {
      position: absolute; inset: 0; pointer-events: none; display: grid; grid-template-rows: auto 1fr auto; padding: 14px; gap: 8px;
    }
    .topbar { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
    .pill { pointer-events: auto; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); border-radius: 999px; padding: 8px 12px; display: inline-flex; gap: 10px; align-items: center; backdrop-filter: blur(6px); }
    .pill b { color: var(--fg); }
    .pill small { opacity: .8; }

    .centerOverlay {
      position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;
    }
    .panel { pointer-events: auto; background: rgba(12,14,30,.85); border: 1px solid rgba(255,255,255,.08); border-radius: 18px; padding: 22px 20px; max-width: 520px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,.45); }
    .title { font-weight: 800; font-size: 28px; letter-spacing: .2px; }
    .muted { opacity: .85; }
    .btnRow { display:flex; gap:10px; justify-content:center; margin-top: 14px; flex-wrap: wrap; }
    button {
      cursor: pointer; background: linear-gradient(180deg, #1f2445, #181c36); color: var(--fg); border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px; padding: 10px 16px; font-weight: 700; letter-spacing: .2px; box-shadow: 0 6px 18px rgba(0,0,0,.35);
      transition: transform .06s ease, box-shadow .06s ease, background .2s ease;
    }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(1px); box-shadow: 0 2px 8px rgba(0,0,0,.45); }
    .btnPrimary { background: linear-gradient(180deg, #3b82f6, #2563eb); border-color: rgba(0,0,0,.15); color: white; }
    .btnDanger { background: linear-gradient(180deg, #ef4444, #dc2626); color: white; }

    .toast { position:absolute; left:50%; transform:translateX(-50%); bottom: 14px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); padding:8px 12px; border-radius:10px; backdrop-filter: blur(6px); }

    .ribbon { position: absolute; left:50%; transform: translateX(-50%); top: 64px; padding: 6px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.1); background: rgba(255,255,255,.06); font-weight: 700; letter-spacing: .3px; z-index: 2; }

    .grade { font-weight: 900; font-size: 20px; }
    .grade.S { color: #8bffb9; }
    .grade.A { color: #b4ff8b; }
    .grade.B { color: #f7ff8b; }
    .grade.C { color: #ffd38b; }
    .grade.D { color: #ff9d8b; }

    .hide { display: none !important; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1280" height="720" aria-label="Baguette Splitter"></canvas>
    <div class="hud">
      <div class="topbar">
        <div style="display:flex; gap:10px; align-items:center">
          <div class="pill"><b>ì ìˆ˜</b><small id="sc">0</small></div>
          <div class="pill"><b>ì»·</b><small id="cuts">0</small></div>
          <div class="pill"><b>ì†ë„</b><small id="spd">0</small></div>
        </div>
        <button id="btnBgmTop" style="pointer-events:auto">ğŸµ ìŒì•… ì¼œê¸°</button>
      </div>
      <div class="centerOverlay">
        <div id="startPanel" class="panel">
          <div class="title">ğŸ¥– Baguette Splitter</div>
          <p class="muted">ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ <b>ì„¸ë¡œ ì»¤í„°</b>ë¥¼ ë©ˆì¶”ê³ , ë°”ê²ŒíŠ¸ë¥¼ ìµœëŒ€í•œ <b>ê· ë“±í•˜ê²Œ</b> ì˜ë¼ë³´ì„¸ìš”.<br/>í° ì¡°ê°ì€ ì‚¬ë¼ì§€ê³  <b>ì‘ì€ ì¡°ê°ë§Œ</b> ë‚¨ìŠµë‹ˆë‹¤.</p>
          <ul style="text-align:left; line-height:1.7; margin: 12px 0 0 0; padding: 0 0 0 18px;">
            <li><b>Space</b>: ìë¥´ê¸° / ì§„í–‰</li>
            <li><b>R</b>: ì¬ì‹œì‘</li>
            <li><b>ë§ˆìš°ìŠ¤</b>: ë²„íŠ¼ í´ë¦­</li>
          </ul>
          <div class="btnRow">
            <button id="btnStart" class="btnPrimary">ê²Œì„ ì‹œì‘</button>
            <button id="btnMute">ğŸ”ˆ íš¨ê³¼ìŒ ë„ê¸°</button>
            <button id="btnBgm">ğŸµ ìŒì•… ì¼œê¸°</button>
          </div>
        </div>
        <div id="gameOverPanel" class="panel hide">
          <div class="title">ê²Œì„ ì˜¤ë²„</div>
          <p class="muted">ì»¤í„°ê°€ ë°”ê²ŒíŠ¸ ë°–ì—ì„œ ë©ˆì·„ì–´ìš”.</p>
          <p style="margin:8px 0 0"><b>ìµœì¢… ì ìˆ˜</b>: <span id="finalScore">0</span> / <b>ì´ ì»·</b>: <span id="finalCuts">0</span></p>
          <p style="margin:8px 0 0">ë§ˆì§€ë§‰ ì»· ë“±ê¸‰: <span id="lastGrade" class="grade">-</span></p>
          <div class="btnRow">
            <button id="btnRestart" class="btnPrimary">ë‹¤ì‹œí•˜ê¸° (R)</button>
            <button id="btnHome">íƒ€ì´í‹€ë¡œ</button>
          </div>
        </div>
      </div>
      <div class="ribbon" id="ribbon">ê· ë“± ë³´ë„ˆìŠ¤: <span id="bonus">0</span></div>
      <div class="toast">ìë¥´ê¸° ìœ„ì¹˜ê°€ <b>ë‚¨ì€ ì¡°ê° ë²”ìœ„ ë°–</b>ì´ë©´ ì¦‰ì‹œ ê²Œì„ì˜¤ë²„!</div>
    </div>
  </div>

  <!-- ğŸ”Š ì˜¤ë””ì˜¤(ë¹Œë“œ ì‹œ êµì²´í•´ ì‚¬ìš©) -->
  <audio id="sCut" preload="auto"></audio>
  <audio id="sGood" preload="auto"></audio>
  <audio id="sFail" preload="auto"></audio>

  <!-- ğŸµ ë°°ê²½ìŒì•…(BGM, ë¹Œë“œì‹œ êµì²´) -->
  <audio id="bgm" preload="auto" loop></audio>

  <script>
  ;(() => {
    // ====== ì„¤ì • (í•„ìš”ì‹œ ìˆ˜ì •) ======
    const CONFIG = {
      baseSpeed: 240,        // px/s ì‹œì‘ ì†ë„(ì»¤í„°)
      speedGain: 100,         // ì»·ë§ˆë‹¤ ì†ë„ ì¦ê°€
      minPieceWidth: 8,     // ë‚¨ì€ ì¡°ê° ìµœì†Œ í­(ì‹œê°ì  ì•ˆì •ì„±)
      scoreBase: 450,        // ê¸°ë³¸ ì ìˆ˜
      scoreMaxBonus: 400,    // ê· ë“± ë³´ë„ˆìŠ¤ ìµœëŒ€ì¹˜ (ì´ 1000ì  ë§Œì  ëŠë‚Œ)
      cutterWidth: 3,        // ì»¤í„° ì„¸ë¡œì„  ë‘ê»˜
      cutterGlow: true,      // ê¸€ë¡œìš° íš¨ê³¼ ì¼œê¸°
      spriteUrl: "assets/baguette.png", // ğŸ–¼ï¸ ë°”ê²ŒíŠ¸ ìŠ¤í”„ë¼ì´íŠ¸(ë¹Œë“œì‹œ êµì²´)
      sfx: {
        cut: "assets/cut.wav",
        good: "assets/good.wav",
        fail: "assets/fail.wav"
      }
    }

    // ====== ìƒíƒœ ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudSc = document.getElementById('sc');
    const hudCuts = document.getElementById('cuts');
    const hudSpd = document.getElementById('spd');
    const startPanel = document.getElementById('startPanel');
    const overPanel = document.getElementById('gameOverPanel');
    const btnStart = document.getElementById('btnStart');
    const btnRestart = document.getElementById('btnRestart');
    const btnHome = document.getElementById('btnHome');
    const btnMute = document.getElementById('btnMute');
    const btnBgmTop = document.getElementById('btnBgmTop');
    const btnBgm = document.getElementById('btnBgm');
    const ribbonBonus = document.getElementById('bonus');
    const finalScore = document.getElementById('finalScore');
    const finalCuts = document.getElementById('finalCuts');
    const lastGrade = document.getElementById('lastGrade');

    const sCut = document.getElementById('sCut');
    const sGood = document.getElementById('sGood');
    const sFail = document.getElementById('sFail');
    const bgm = document.getElementById('bgm');

    // SFX íŒŒì¼ ê²½ë¡œ ì ìš©(ë¹ˆ íŒŒì¼ì´ì–´ë„ ë¬´ê´€)
    sCut.src = CONFIG.sfx.cut; sGood.src = CONFIG.sfx.good; sFail.src = CONFIG.sfx.fail;
    bgm.src = 'assets/bgm.mp3'; // êµì²´í•´ì„œ ì‚¬ìš©

    let isMuted = false;
    let isBgmOn = false;
    const play = (a) => { if (!isMuted && a && a.play) { a.currentTime = 0; a.play().catch(()=>{}); } };

    function setMuted(next) {
      isMuted = next;
      btnMute.textContent = isMuted ? 'ğŸ”‡ íš¨ê³¼ìŒ ì¼œê¸°' : 'ğŸ”ˆ íš¨ê³¼ìŒ ë„ê¸°';
    }

    function setBgm(next){
      isBgmOn = next;
      const label = isBgmOn ? 'ğŸµ ìŒì•… ë„ê¸°' : 'ğŸµ ìŒì•… ì¼œê¸°';
      btnBgmTop.textContent = label;
      btnBgm.textContent = label;
      if (isBgmOn) { bgm.volume = 0.7; bgm.play().catch(()=>{}); }
      else { bgm.pause(); }
    }

    // í™”ë©´ ìŠ¤ì¼€ì¼(DPR) ëŒ€ì‘
    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = 1280, h = 720;
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ë°”ê²ŒíŠ¸ ìŠ¤í”„ë¼ì´íŠ¸ ë¡œë“œ(ì—†ìœ¼ë©´ ê·¸ë¼ë””ì–¸íŠ¸ë¡œ ëŒ€ì²´)
    const baguetteImg = new Image();
    let spriteReady = false;
    baguetteImg.onload = () => { spriteReady = true; };
    baguetteImg.onerror = () => { spriteReady = false; };
    baguetteImg.src = CONFIG.spriteUrl;

    const W = 1280, H = 720; // ë…¼ë¦¬ í¬ê¸°ëŠ” ìœ ì§€í•˜ê³ , ì‹¤ì œ í‘œì‹œí­ì€ CSSë¡œ ì•½ê°„ ì¶•ì†Œ

    const GameState = {
      Idle: 'idle',
      Running: 'running',
      Over: 'over'
    };

    let state = GameState.Idle;

    // ë‚¨ì€ ì¡°ê°(ë°”ê²ŒíŠ¸) ëª¨ë¸: x,yëŠ” ì¤‘ì‹¬ ê¸°ì¤€
    const baguette = {
      x: W/2,
      y: H/2,
      width: 780,
      height: 120
    };

    // ìµœì´ˆ ë°”ê²ŒíŠ¸ì˜ ê¸°ì¤€ ë²”ìœ„(í™”ë©´ ì¢Œí‘œ)
    let baseLeft = baguette.x - baguette.width/2;
    let baseRight = baguette.x + baguette.width/2;

    // ì‹¤ì œë¡œ ë‚¨ì•„ìˆëŠ” ì¡°ê°ì˜ í˜„ì¬ ë²”ìœ„(í™”ë©´ ì¢Œí‘œ)
    let pieceLeft = baseLeft;
    let pieceRight = baseRight;

    // ì»¤í„°(ì„¸ë¡œì¤„) ì´ë™ ê°€ëŠ¥ ë²”ìœ„: ìµœì´ˆ ë°”ê²ŒíŠ¸ í­ì—ì„œ í¬ê²Œ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ íŒ¨ë”©ë§Œ ì¶”ê°€
    const boundPad = 12; // ì•½ê°„ì˜ ì—¬ìœ 
    let moveMinX = baseLeft - boundPad;
    let moveMaxX = baseRight + boundPad;

    // ì»¤í„°(ì„¸ë¡œì¤„)
    let cutter = {
      x: moveMinX, // ì´ˆê¸° ìœ„ì¹˜: ì¢Œì¸¡ì—ì„œ ì‹œì‘
      dir: 1,     // 1: ì˜¤ë¥¸ìª½, -1: ì™¼ìª½
      speed: CONFIG.baseSpeed
    };


    let score = 0;
    let cuts = 0;
    let lastBonus = 0;

    function resetGame(toTitle = false) {
      // ë°”ê²ŒíŠ¸ ì´ˆê¸°í™”
      baguette.x = W/2; baguette.y = H/2; baguette.width = 780; baguette.height = 120;
      // ê¸°ì¤€/ì¡°ê° ë²”ìœ„ ì¬ê³„ì‚°
      baseLeft = baguette.x - baguette.width/2;
      baseRight = baguette.x + baguette.width/2;
      pieceLeft = baseLeft; pieceRight = baseRight;
      moveMinX = baseLeft - boundPad; moveMaxX = baseRight + boundPad;
      // ì»¤í„° ì´ˆê¸°í™”(ì¢Œì¸¡ì—ì„œ ì‹œì‘)
      cutter.x = moveMinX; cutter.dir = 1; cutter.speed = CONFIG.baseSpeed;
      score = 0; cuts = 0; lastBonus = 0;
      updateHud();
      lastGrade.textContent = '-'; lastGrade.className = 'grade';
      if (toTitle) { state = GameState.Idle; showStart(); } else { hideStart(); state = GameState.Running; }
      hideOver();
    } 

    function updateHud() {
      hudSc.textContent = Math.floor(score);
      hudCuts.textContent = cuts;
      hudSpd.textContent = Math.round(cutter.speed) + ' px/s';
      ribbonBonus.textContent = lastBonus;
    }

    function showStart(){ startPanel.classList.remove('hide'); }
    function hideStart(){ startPanel.classList.add('hide'); }
    function showOver(){ overPanel.classList.remove('hide'); }
    function hideOver(){ overPanel.classList.add('hide'); }

    // ë“±ê¸‰ ë¬¸ìì—´
    function gradeFromBonus(b) {
      if (b >= 850) return 'S';
      if (b >= 700) return 'A';
      if (b >= 500) return 'B';
      if (b >= 300) return 'C';
      return 'D';
    }

    // ìë¥´ê¸° ì²˜ë¦¬
    function cutNow() {
      if (state !== GameState.Running) return;
      const cutX = Math.round(cutter.x);

      // ë‚¨ì€ ì¡°ê° ë²”ìœ„
      const left = pieceLeft;
      const right = pieceRight;

      // ë²”ìœ„ ë°–ì´ë©´ ê²Œì„ì˜¤ë²„
      if (cutX <= left || cutX >= right) {
        play(sFail);
        endGame();
        return;
      }

      // ì™¼/ì˜¤ ì”ì—¬ í­ (í™”ë©´ ì¢Œí‘œ ê¸°ì¤€)
      const leftW = cutX - left;
      const rightW = right - cutX;

      // ë” ì‘ì€ ì¡°ê°ë§Œ ë‚¨ê¹€
      const keepLeft = leftW <= rightW;

      // ê· ë“± ë³´ë„ˆìŠ¤ (ì‘ì„ìˆ˜ë¡ ê· ë“±)
      const r = Math.min(leftW, rightW) / Math.max(leftW, rightW); // 0..1
      const bonus = Math.round(CONFIG.scoreMaxBonus * r);
      lastBonus = bonus;

      // ì ìˆ˜ ê°±ì‹ 
     score = 2*score;
     score += CONFIG.scoreBase + bonus;
      cuts += 1;

      // ë‚¨ì€ ì¡°ê° ë²”ìœ„ ê°±ì‹  (ê¸°ì¤€ ì¢Œí‘œë¡œ ë³´ì¡´)
      if (keepLeft) {
        pieceRight = cutX; // ì¢Œì¸¡ ì¡°ê°ë§Œ ìœ ì§€
      } else {
        pieceLeft = cutX;  // ìš°ì¸¡ ì¡°ê°ë§Œ ìœ ì§€
      }

      // ë°”ê²ŒíŠ¸ì˜ í‘œì‹œìš© ì¤‘ì‹¬/í­ ì¬ê³„ì‚°(ì™œê³¡ ì—†ì´ ì‹¤ì¢Œí‘œ ë°˜ì˜)
      baguette.width = Math.max(CONFIG.minPieceWidth, pieceRight - pieceLeft);
      baguette.x = pieceLeft + baguette.width/2;

      // ì†ë„ ì¦ê°€
      cutter.speed += CONFIG.speedGain;

      // ì»¤í„°ë¥¼ ì´ˆê¸° ìœ„ì¹˜ë¡œ ì¬ë°°ì¹˜(ì¢Œì¸¡ì—ì„œ ë‹¤ì‹œ ì‹œì‘)
      cutter.x = moveMinX; cutter.dir = 1;

      // ì„±ê³µ SFX
      play(sCut);
      play(sGood);

      updateHud();
    }

    function endGame() {
      state = GameState.Over;
      finalScore.textContent = Math.floor(score);
      finalCuts.textContent = cuts;
      const g = gradeFromBonus(lastBonus);
      lastGrade.textContent = g; lastGrade.className = 'grade ' + g;
      showOver();
    }

    // ì…ë ¥
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (state === GameState.Idle) { hideStart(); state = GameState.Running; if (!isBgmOn) setBgm(true); return; }
        if (state === GameState.Running) { cutNow(); return; }
        if (state === GameState.Over) { resetGame(false); return; }
      }
      if (e.key === 'r' || e.key === 'R') { resetGame(false); }
      if (e.key === 'm' || e.key === 'M') { setMuted(!isMuted); }
      if (e.key === 'b' || e.key === 'B') { setBgm(!isBgmOn); }
    });

    btnStart.addEventListener('click', () => { hideStart(); state = GameState.Running; if (!isBgmOn) setBgm(true); });
    btnRestart?.addEventListener('click', () => resetGame(false));
    btnHome?.addEventListener('click', () => resetGame(true));
    btnMute.addEventListener('click', () => setMuted(!isMuted));
    btnBgmTop.addEventListener('click', ()=> setBgm(!isBgmOn));
    btnBgm.addEventListener('click', ()=> setBgm(!isBgmOn));

    // ëª¨ë°”ì¼/í„°ì¹˜ ì§€ì›: í™”ë©´ì„ íƒ­í•˜ë©´ Space ë™ì‘ê³¼ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
    function handleTap(e){
      if (e && e.preventDefault) e.preventDefault();
      // ë²„íŠ¼/ë§í¬/í¼ ìœ„ íƒ­ì€ ë¬´ì‹œ (ê¸°ì¡´ í´ë¦­ ë™ì‘ ìœ ì§€)
      const blocked = e.target && e.target.closest && e.target.closest('button,a,input,textarea,select,label');
      if (blocked) return;
      if (state === GameState.Idle) { hideStart(); state = GameState.Running; if (!isBgmOn) setBgm(true); return; }
      if (state === GameState.Running) { cutNow(); return; }
      if (state === GameState.Over) { resetGame(false); return; }
    }
    // ìµœì‹  ë¸Œë¼ìš°ì €: pointerdown ìš°ì„  + ë ˆê±°ì‹œ í„°ì¹˜
    document.addEventListener('pointerdown', handleTap, { passive: false });
    document.addEventListener('touchstart', handleTap, { passive: false });

    // ê·¸ë¦¬ê¸° ìœ í‹¸
    function drawCutter() {
      const x = Math.round(cutter.x) + .5; // crisp line
      ctx.save();
      if (CONFIG.cutterGlow) {
        ctx.shadowColor = 'rgba(141,215,255,.6)';
        ctx.shadowBlur = 12;
      }
      ctx.strokeStyle = '#8dd7ff';
      ctx.lineWidth = CONFIG.cutterWidth;
      ctx.beginPath();
      ctx.moveTo(x, 120);
      ctx.lineTo(x, H-120);
      ctx.stroke();
      ctx.restore();

      // ë¨¸ë¦¬í‘œì‹œ(ì‚¼ê°)
      ctx.save();
      ctx.fillStyle = '#8dd7ff';
      ctx.beginPath();
      ctx.moveTo(x, 96); ctx.lineTo(x-8, 116); ctx.lineTo(x+8, 116); ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(x, H-96); ctx.lineTo(x-8, H-116); ctx.lineTo(x+8, H-116); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawBaguette() {
      const { y, height:h } = baguette;
      const w = pieceRight - pieceLeft;
      const x = pieceLeft + w/2;
      const left = pieceLeft, top = y - h/2;

      // ê·¸ë¦¼ì ë°›ì¹¨
      ctx.save();
      ctx.globalAlpha = .3;
      ctx.fillStyle = '#000';
      const shadowH = 14;
      ctx.beginPath();
      ctx.ellipse(x, y + h/2 + 16, w*0.9, shadowH, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // ìŠ¤í”„ë¼ì´íŠ¸ë¥¼ 'ë¶€ë¶„ ì˜ë¼ì„œ' í‘œì‹œ(ê°€ë¡œ ì™œê³¡ ì—†ì´)
      if (spriteReady) {
        const relStart = (pieceLeft - baseLeft) / (baseRight - baseLeft);
        const relEnd = (pieceRight - baseLeft) / (baseRight - baseLeft);
        const sx = Math.max(0, Math.floor(baguetteImg.width * relStart));
        const sw = Math.max(1, Math.floor(baguetteImg.width * (relEnd - relStart)));
        const sy = 0;
        const sh = baguetteImg.height;
        ctx.drawImage(baguetteImg, sx, sy, sw, sh, left, top, w, h);
      } else {
        // ëŒ€ì²´ ê·¸ë¼ë””ì–¸íŠ¸(ë¶€ë¶„ë§Œ í‘œì‹œ)
        const g = ctx.createLinearGradient(left, top, left, top+h);
        g.addColorStop(0, '#f6c27a');
        g.addColorStop(1, '#e3a85a');
        ctx.fillStyle = g;
        roundRect(ctx, left, top, w, h, h/2);
        ctx.fill();
        // ë‹¨ìˆœ ê²°ë¬´ëŠ¬ë„ ë¶€ë¶„ ë¹„ìœ¨ë¡œ í‘œì‹œ
        ctx.globalAlpha = .2; ctx.fillStyle = '#8b5e34';
        const baseW = (baseRight - baseLeft);
        for (let i=0;i<5;i++) {
          const t = (i+1)/6; // 1/6, 2/6, ...
          const rxBase = baseLeft + baseW*t;
          if (rxBase > pieceLeft && rxBase < pieceRight) {
            const rx = rxBase; // í™”ë©´ ì¢Œí‘œ ê·¸ëŒ€ë¡œ
            ctx.beginPath(); ctx.ellipse(rx, y, 10, h/3, 0, 0, Math.PI*2); ctx.fill();
          }
        }
        ctx.globalAlpha = 1;
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, h/2, w/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // ë°°ê²½ ìš”ì†Œ
    function drawBackground(t) {
      // ê·¸ë¦¬ë“œ/ìŠ¤ìº”ë¼ì¸ ëŠë‚Œ
      ctx.save();
      ctx.globalAlpha = .12;
      ctx.strokeStyle = '#8dd7ff';
      ctx.lineWidth = 1;
      const gap = 40;
      const phase = (t*0.05)%gap;
      for (let x= (W%gap)-phase; x<W; x+=gap) {
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
      }
      ctx.globalAlpha = .06;
      for (let y= (H%gap); y<H; y+=gap) {
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
      }
      ctx.restore();
    }

    // ë©”ì¸ ë£¨í”„
    let lastTime = performance.now();
    function tick(now) {
      const dt = Math.min(1/30, (now - lastTime) / 1000);
      lastTime = now;

      // ì—…ë°ì´íŠ¸
      if (state === GameState.Running) {
        cutter.x += cutter.dir * cutter.speed * dt;
        if (cutter.x <= moveMinX) { cutter.x = moveMinX; cutter.dir = 1; }
        if (cutter.x >= moveMaxX) { cutter.x = moveMaxX; cutter.dir = -1; }
      }

      // ê·¸ë¦¬ê¸°
      ctx.clearRect(0,0,W,H);
      drawBackground(now/16);

      // ë‚¨ì€ ë°”ê²ŒíŠ¸(ê°€ìš´ë° ìˆ˜í‰)
      drawBaguette();

      // ì»¤í„°
      drawCutter();

      requestAnimationFrame(tick);
    }

    // ì´ˆê¸° ìƒíƒœë¡œ ì‹œì‘
    updateHud();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>