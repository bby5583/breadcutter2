<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Baguette Splitter</title>
  <style>
    :root {
      --bg: #0f1220;
      --fg: #e7e9ee;
      --accent: #8dd7ff;
      --accent2: #ffc36b;
      --danger: #ff6b6b;
      --panel: #171a2b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 50% -200px, #1a1e34 0%, var(--bg) 60%);
      color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      display: grid; place-items: center; overflow: hidden;
    }
    #wrap { position: relative; width: min(100vw, 980px); aspect-ratio: 16 / 9; }
    canvas { width: 100%; height: auto; display: block; border-radius: 18px; box-shadow: 0 20px 60px rgba(0,0,0,.45); background: linear-gradient(180deg, #101427, #0b0e1c 80%); touch-action: manipulation; }

    .hud {
      position: absolute; inset: 0; pointer-events: none; display: grid; grid-template-rows: auto 1fr auto; padding: 14px; gap: 8px;
    }
    .topbar { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
    .pill { pointer-events: auto; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); border-radius: 999px; padding: 8px 12px; display: inline-flex; gap: 10px; align-items: center; backdrop-filter: blur(6px); }
    .pill b { color: var(--fg); }
    .pill small { opacity: .8; }

    .centerOverlay {
      position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;
    }
    .panel { pointer-events: auto; background: rgba(12,14,30,.85); border: 1px solid rgba(255,255,255,.08); border-radius: 18px; padding: 22px 20px; max-width: 520px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,.45); }
    .title { font-weight: 800; font-size: 28px; letter-spacing: .2px; }
    .muted { opacity: .85; }
    .btnRow { display:flex; gap:10px; justify-content:center; margin-top: 14px; flex-wrap: wrap; }
    button {
      cursor: pointer; background: linear-gradient(180deg, #1f2445, #181c36); color: var(--fg); border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px; padding: 10px 16px; font-weight: 700; letter-spacing: .2px; box-shadow: 0 6px 18px rgba(0,0,0,.35);
      transition: transform .06s ease, box-shadow .06s ease, background .2s ease;
    }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(1px); box-shadow: 0 2px 8px rgba(0,0,0,.45); }
    .btnPrimary { background: linear-gradient(180deg, #3b82f6, #2563eb); border-color: rgba(0,0,0,.15); color: white; }
    .btnDanger { background: linear-gradient(180deg, #ef4444, #dc2626); color: white; }

    .toast { position:absolute; left:50%; transform:translateX(-50%); bottom: 14px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); padding:8px 12px; border-radius:10px; backdrop-filter: blur(6px); }

    .ribbon { position: absolute; left:50%; transform: translateX(-50%); top: 64px; padding: 6px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.1); background: rgba(255,255,255,.06); font-weight: 700; letter-spacing: .3px; z-index: 2; }

    .grade { font-weight: 900; font-size: 20px; }
    .grade.S { color: #8bffb9; }
    .grade.A { color: #b4ff8b; }
    .grade.B { color: #f7ff8b; }
    .grade.C { color: #ffd38b; }
    .grade.D { color: #ff9d8b; }

    .hide { display: none !important; }
  :root { --safe-top: env(safe-area-inset-top); --safe-bottom: env(safe-area-inset-bottom); --safe-left: env(safe-area-inset-left); --safe-right: env(safe-area-inset-right); }

@media (orientation: portrait) {
  body { padding: calc(var(--safe-top) + 8px) max(8px, var(--safe-left)) calc(var(--safe-bottom) + 8px) max(8px, var(--safe-right)); }
  #wrap { width: 100vw; height: 100vh; aspect-ratio: auto; }
  .hud { padding: 10px; grid-template-rows: auto 1fr auto; }
  .topbar { flex-wrap: wrap; gap: 6px; }
  .pill { padding: 10px 14px; font-size: 14px; }
  .title { font-size: 32px; }
  button { padding: 14px 18px; font-size: 16px; }
  .ribbon { top: auto; bottom: 96px; }
  .toast { bottom: 12px; font-size: 14px; }
}

</style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1280" height="720" aria-label="Baguette Splitter"></canvas>
    <div class="hud">
      <div class="topbar">
        <div style="display:flex; gap:10px; align-items:center">
          <div class="pill"><b>ì ìˆ˜</b><small id="sc">0</small></div>
          <div class="pill"><b>ì»·</b><small id="cuts">0</small></div>
          <div class="pill"><b>ì†ë„</b><small id="spd">0</small></div>
        </div>
        <button id="btnBgmTop" style="pointer-events:auto">ğŸµ ìŒì•… ì¼œê¸°</button>
      </div>
      <div class="centerOverlay">
        <div id="startPanel" class="panel">
          <div class="title">ğŸ¥– Baguette Splitter</div>
          <p class="muted">ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ <b>ì„¸ë¡œ ì»¤í„°</b>ë¥¼ ë©ˆì¶”ê³ , ë°”ê²ŒíŠ¸ë¥¼ ìµœëŒ€í•œ <b>ê· ë“±í•˜ê²Œ</b> ì˜ë¼ë³´ì„¸ìš”.<br/>í° ì¡°ê°ì€ ì‚¬ë¼ì§€ê³  <b>ì‘ì€ ì¡°ê°ë§Œ</b> ë‚¨ìŠµë‹ˆë‹¤.</p>
          <ul style="text-align:left; line-height:1.7; margin: 12px 0 0 0; padding: 0 0 0 18px;">
            <li><b>Space</b>: ìë¥´ê¸° / ì§„í–‰</li>
            <li><b>R</b>: ì¬ì‹œì‘</li>
            <li><b>ë§ˆìš°ìŠ¤</b>: ë²„íŠ¼ í´ë¦­</li>
          </ul>
          <div class="btnRow">
            <button id="btnStart" class="btnPrimary">ê²Œì„ ì‹œì‘</button>
            <button id="btnMute">ğŸ”ˆ íš¨ê³¼ìŒ ë„ê¸°</button>
            <button id="btnBgm">ğŸµ ìŒì•… ì¼œê¸°</button>
          </div>
        </div>
        <div id="gameOverPanel" class="panel hide">
          <div class="title">ê²Œì„ ì˜¤ë²„</div>
          <p class="muted">ì»¤í„°ê°€ ë°”ê²ŒíŠ¸ ë°–ì—ì„œ ë©ˆì·„ì–´ìš”.</p>
          <p style="margin:8px 0 0"><b>ìµœì¢… ì ìˆ˜</b>: <span id="finalScore">0</span> / <b>ì´ ì»·</b>: <span id="finalCuts">0</span></p>
          <p style="margin:8px 0 0">ë§ˆì§€ë§‰ ì»· ë“±ê¸‰: <span id="lastGrade" class="grade">-</span></p>
          <div class="btnRow">
            <button id="btnRestart" class="btnPrimary">ë‹¤ì‹œí•˜ê¸° (R)</button>
            <button id="btnHome">íƒ€ì´í‹€ë¡œ</button>
          </div>
        </div>
      </div>
      <div class="ribbon" id="ribbon">ê· ë“± ë³´ë„ˆìŠ¤: <span id="bonus">0</span></div>
      <div class="toast">ìë¥´ê¸° ìœ„ì¹˜ê°€ <b>ë‚¨ì€ ì¡°ê° ë²”ìœ„ ë°–</b>ì´ë©´ ì¦‰ì‹œ ê²Œì„ì˜¤ë²„!</div>
    </div>
  </div>

  <!-- ğŸ”Š ì˜¤ë””ì˜¤(ë¹Œë“œ ì‹œ êµì²´í•´ ì‚¬ìš©) -->
  <audio id="sCut" preload="auto"></audio>
  <audio id="sGood" preload="auto"></audio>
  <audio id="sFail" preload="auto"></audio>

  <!-- ğŸµ ë°°ê²½ìŒì•…(BGM, ë¹Œë“œì‹œ êµì²´) -->
  <audio id="bgm" preload="auto" loop></audio>

  <script>
  ;(() => {
    // ====== ì„¤ì • ======
    const CONFIG = {
      baseSpeed: 240,        // px/s ì‹œì‘ ì†ë„(ì»¤í„°)
      speedGain: 100,         // ì»·ë§ˆë‹¤ ì†ë„ ì¦ê°€
      minPieceWidth: 8,     // ë‚¨ì€ ì¡°ê° ìµœì†Œ í­(ì‹œê°ì  ì•ˆì •ì„±)
      scoreBase: 450,        // ê¸°ë³¸ ì ìˆ˜
      scoreMaxBonus: 400,    // ê· ë“± ë³´ë„ˆìŠ¤ ìµœëŒ€ì¹˜ (ì´ 1000ì  ë§Œì  ëŠë‚Œ)
      cutterWidth: 3,        // ì»¤í„° ì„¸ë¡œì„  ë‘ê»˜
      cutterGlow: true,      // ê¸€ë¡œìš° íš¨ê³¼ ì¼œê¸°
      spriteUrl: "assets/baguette.png",
      sfx: { cut: "assets/cut.wav", good: "assets/good.wav", fail: "assets/fail.wav" }
    };

    // ====== ì—˜ë¦¬ë¨¼íŠ¸ ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const wrap = document.getElementById('wrap');

    const hudSc = document.getElementById('sc');
    const hudCuts = document.getElementById('cuts');
    const hudSpd = document.getElementById('spd');
    const startPanel = document.getElementById('startPanel');
    const overPanel = document.getElementById('gameOverPanel');
    const btnStart = document.getElementById('btnStart');
    const btnRestart = document.getElementById('btnRestart');
    const btnHome = document.getElementById('btnHome');
    const btnMute = document.getElementById('btnMute');
    const btnBgmTop = document.getElementById('btnBgmTop');
    const btnBgm = document.getElementById('btnBgm');

    const ribbonBonus = document.getElementById('bonus');
    const finalScore = document.getElementById('finalScore');
    const finalCuts = document.getElementById('finalCuts');
    const lastGrade = document.getElementById('lastGrade');

    const sCut = document.getElementById('sCut');
    const sGood = document.getElementById('sGood');
    const sFail = document.getElementById('sFail');
    const bgm = document.getElementById('bgm');

    // ì˜¤ë””ì˜¤ ê²½ë¡œ
    sCut.src = CONFIG.sfx.cut; sGood.src = CONFIG.sfx.good; sFail.src = CONFIG.sfx.fail;
    bgm.src = 'assets/bgm.mp3';

    // ====== ìƒíƒœ ======
    let isMuted = false;
    let isBgmOn = false;
    let isPortrait = window.matchMedia('(orientation: portrait)').matches;

    // ë…¼ë¦¬ í•´ìƒë„(ì„¸ë¡œ: 720x1280, ê°€ë¡œ: 1280x720)
    let W = isPortrait ? 720 : 1280;
    let H = isPortrait ? 1280 : 720;

    const GameState = { Idle: 'idle', Running: 'running', Over: 'over' };
    let state = GameState.Idle;

    // ì¡°ì‘ ê°€ë“œ(ì‹œì‘ ì§í›„ íƒ­ ë¬´ì‹œ)
    let inputLockUntil = 0;
    const lockInput = (ms=300) => { inputLockUntil = performance.now() + ms; };

    // ê²Œì„ ëª¨ë¸
    const baguette = { x: W/2, y: H/2, width: 780, height: 120 };
    let baseLeft = baguette.x - baguette.width/2;
    let baseRight = baguette.x + baguette.width/2;
    let pieceLeft = baseLeft;
    let pieceRight = baseRight;
    const boundPad = 12;
    let moveMinX = baseLeft - boundPad;
    let moveMaxX = baseRight + boundPad;

    let cutter = { x: moveMinX, dir: 1, speed: CONFIG.baseSpeed };

    let score = 0;
    let cuts = 0;
    let lastBonus = 0;

    // ====== ìœ í‹¸ ======
    const play = (a) => { if (!isMuted && a && a.play) { a.currentTime = 0; a.play().catch(()=>{}); } };
    function setMuted(next) { isMuted = next; btnMute.textContent = isMuted ? 'ğŸ”‡ íš¨ê³¼ìŒ ì¼œê¸°' : 'ğŸ”ˆ íš¨ê³¼ìŒ ë„ê¸°'; }
    function setBgm(next) {
      isBgmOn = next;
      const label = isBgmOn ? 'ğŸµ ìŒì•… ë„ê¸°' : 'ğŸµ ìŒì•… ì¼œê¸°';
      if (btnBgmTop) btnBgmTop.textContent = label;
      if (btnBgm) btnBgm.textContent = label;
      if (isBgmOn) { bgm.volume = 0.7; bgm.play().catch(()=>{}); } else { bgm.pause(); }
    }

    function updateHud(){
      hudSc.textContent = Math.floor(score);
      hudCuts.textContent = cuts;
      hudSpd.textContent = Math.round(cutter.speed) + ' px/s';
      ribbonBonus.textContent = lastBonus;
    }

    function showStart(){ startPanel.classList.remove('hide'); }
    function hideStart(){ startPanel.classList.add('hide'); }
    function showOver(){ overPanel.classList.remove('hide'); }
    function hideOver(){ overPanel.classList.add('hide'); }

    // ë“±ê¸‰
    function gradeFromBonus(b){ if (b>=850) return 'S'; if (b>=700) return 'A'; if (b>=500) return 'B'; if (b>=300) return 'C'; return 'D'; }

    // ====== ìº”ë²„ìŠ¤/ë ˆì´ì•„ì›ƒ ======
    function resizeCanvas(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function setWrapSize(){
      const vw = window.innerWidth, vh = window.innerHeight;
      const ar = isPortrait ? (9/16) : (16/9);
      let w = vw, h = Math.round(w / ar);
      if (h > vh) { h = vh; w = Math.round(h * ar); }
      wrap.style.width = w + 'px';
      wrap.style.height = h + 'px';
    }

    function detectOrientation(){
      const next = window.matchMedia('(orientation: portrait)').matches;
      if (next !== isPortrait){
        isPortrait = next;
        W = isPortrait ? 720 : 1280;
        H = isPortrait ? 1280 : 720;
        resetGame(true); // ë°©í–¥ ì „í™˜ ì•ˆì „ ë¦¬ì…‹
      }
    }

    function resizeAll(){ detectOrientation(); resizeCanvas(); setWrapSize(); }
    window.addEventListener('resize', resizeAll);

    // ====== ìŠ¤í”„ë¼ì´íŠ¸ ======
    const baguetteImg = new Image();
    let spriteReady = false;
    baguetteImg.onload = () => { spriteReady = true; };
    baguetteImg.onerror = () => { spriteReady = false; };
    baguetteImg.src = CONFIG.spriteUrl;

    // ====== ê²Œì„ ë¡œì§ ======
    function resetGame(toTitle=false){
      // ë°”ê²ŒíŠ¸/ê²½ê³„ ì¬ì„¤ì • (ìƒˆ W/H ë°˜ì˜)
      baguette.x = W/2; baguette.y = H/2; baguette.width = 780; baguette.height = 120;
      baseLeft = baguette.x - baguette.width/2; baseRight = baguette.x + baguette.width/2;
      pieceLeft = baseLeft; pieceRight = baseRight;
      moveMinX = baseLeft - boundPad; moveMaxX = baseRight + boundPad;
      cutter = { x: moveMinX, dir: 1, speed: CONFIG.baseSpeed };
      score = 0; cuts = 0; lastBonus = 0; updateHud();
      lastGrade.textContent = '-'; lastGrade.className = 'grade';
      hideOver();
      if (toTitle) { state = GameState.Idle; showStart(); } else { hideStart(); state = GameState.Running; }
      resizeAll();
    }

    function cutNow(){
      if (state !== GameState.Running) return;
      const cutX = Math.round(cutter.x);
      const left = pieceLeft, right = pieceRight;
      if (cutX <= left || cutX >= right){ play(sFail); endGame(); return; }
      const leftW = cutX - left; const rightW = right - cutX;
      const keepLeft = leftW <= rightW;
      const r = Math.min(leftW, rightW) / Math.max(leftW, rightW);
      const bonus = Math.round(CONFIG.scoreMaxBonus * r);
      lastBonus = bonus;
      score = 2*score;
      score += CONFIG.scoreBase + bonus; cuts += 1;
      if (keepLeft) pieceRight = cutX; else pieceLeft = cutX;
      baguette.width = Math.max(CONFIG.minPieceWidth, pieceRight - pieceLeft);
      baguette.x = pieceLeft + baguette.width/2;
      cutter.speed += CONFIG.speedGain;
      cutter.x = moveMinX; cutter.dir = 1;
      play(sCut); if (bonus >= 700) play(sGood);
      updateHud();
    }

    function endGame(){
      state = GameState.Over;
      finalScore.textContent = Math.floor(score);
      finalCuts.textContent = cuts;
      const g = gradeFromBonus(lastBonus); lastGrade.textContent = g; lastGrade.className = 'grade ' + g;
      showOver();
    }

    // ====== ì…ë ¥ ======
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space'){
        e.preventDefault();
        if (state === GameState.Idle){ hideStart(); state = GameState.Running; if (!isBgmOn) setBgm(true); lockInput(350); return; }
        if (state === GameState.Running){ cutNow(); return; }
        if (state === GameState.Over){ resetGame(false); lockInput(200); return; }
      }
      if (e.key === 'r' || e.key === 'R') resetGame(false);
      if (e.key === 'm' || e.key === 'M') setMuted(!isMuted);
      if (e.key === 'b' || e.key === 'B') setBgm(!isBgmOn);
    });

    btnStart.addEventListener('click', () => { hideStart(); state = GameState.Running; if (!isBgmOn) setBgm(true); lockInput(350); });
    btnRestart?.addEventListener('click', () => resetGame(false));
    btnHome?.addEventListener('click', () => resetGame(true));
    btnMute.addEventListener('click', () => setMuted(!isMuted));
    btnBgmTop.addEventListener('click', ()=> setBgm(!isBgmOn));
    btnBgm.addEventListener('click', ()=> setBgm(!isBgmOn));

    function handleTap(e){
      if (e && e.preventDefault) e.preventDefault();
      if (performance.now() < inputLockUntil) return; // ì‹œì‘ ì§í›„ íƒ­ ë¬´ì‹œ
      const blocked = e.target && e.target.closest && e.target.closest('button,a,input,textarea,select,label');
      if (blocked) return;
      if (state === GameState.Idle){ hideStart(); state = GameState.Running; if (!isBgmOn) setBgm(true); lockInput(350); return; }
      if (state === GameState.Running){ cutNow(); return; }
      if (state === GameState.Over){ resetGame(false); lockInput(200); return; }
    }
    document.addEventListener('pointerdown', handleTap, { passive: false });

    // ====== ê·¸ë¦¬ê¸° ======
    function drawCutter(){
      const x = Math.round(cutter.x) + .5;
      ctx.save();
      if (CONFIG.cutterGlow){ ctx.shadowColor = 'rgba(141,215,255,.6)'; ctx.shadowBlur = 12; }
      ctx.strokeStyle = '#8dd7ff'; ctx.lineWidth = CONFIG.cutterWidth;
      ctx.beginPath(); ctx.moveTo(x, 120); ctx.lineTo(x, H-120); ctx.stroke(); ctx.restore();
      ctx.save(); ctx.fillStyle = '#8dd7ff';
      ctx.beginPath(); ctx.moveTo(x, 96); ctx.lineTo(x-8, 116); ctx.lineTo(x+8, 116); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(x, H-96); ctx.lineTo(x-8, H-116); ctx.lineTo(x+8, H-116); ctx.closePath(); ctx.fill();
      ctx.restore();
    }

    function drawBaguette(){
      const { y, height:h } = baguette; const w = pieceRight - pieceLeft; const x = pieceLeft + w/2; const left = pieceLeft, top = y - h/2;
      ctx.save(); ctx.globalAlpha = .3; ctx.fillStyle = '#000'; const shadowH = 14; ctx.beginPath(); ctx.ellipse(x, y + h/2 + 16, w*0.9, shadowH, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
      if (spriteReady){
        const relStart = (pieceLeft - baseLeft) / (baseRight - baseLeft);
        const relEnd = (pieceRight - baseLeft) / (baseRight - baseLeft);
        const sx = Math.max(0, Math.floor(baguetteImg.width * relStart));
        const sw = Math.max(1, Math.floor(baguetteImg.width * (relEnd - relStart)));
        const sy = 0; const sh = baguetteImg.height;
        ctx.drawImage(baguetteImg, sx, sy, sw, sh, left, top, w, h);
      } else {
        const g = ctx.createLinearGradient(left, top, left, top+h); g.addColorStop(0, '#f6c27a'); g.addColorStop(1, '#e3a85a'); ctx.fillStyle = g;
        roundRect(ctx, left, top, w, h, h/2); ctx.fill();
        ctx.globalAlpha = .2; ctx.fillStyle = '#8b5e34'; const baseW = (baseRight - baseLeft);
        for (let i=0;i<5;i++){ const t = (i+1)/6; const rxBase = baseLeft + baseW*t; if (rxBase > pieceLeft && rxBase < pieceRight){ const rx = rxBase; ctx.beginPath(); ctx.ellipse(rx, y, 10, h/3, 0, 0, Math.PI*2); ctx.fill(); } }
        ctx.globalAlpha = 1;
      }
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, h/2, w/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawBackground(t){
      ctx.save(); ctx.globalAlpha = .12; ctx.strokeStyle = '#8dd7ff'; ctx.lineWidth = 1; const gap = 40; const phase = (t*0.05)%gap;
      for (let x=(W%gap)-phase; x<W; x+=gap){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      ctx.globalAlpha = .06;
      for (let y=(H%gap); y<H; y+=gap){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      ctx.restore();
    }

    // ====== ë£¨í”„ ======
    let lastTime = performance.now();
    function tick(now){
      const dt = Math.min(1/30, (now - lastTime) / 1000); lastTime = now;
      if (state === GameState.Running){
        cutter.x += cutter.dir * cutter.speed * dt;
        if (cutter.x <= moveMinX) { cutter.x = moveMinX; cutter.dir = 1; }
        if (cutter.x >= moveMaxX) { cutter.x = moveMaxX; cutter.dir = -1; }
      }
      ctx.clearRect(0,0,W,H);
      drawBackground(now/16);
      drawBaguette();
      drawCutter();
      requestAnimationFrame(tick);
    }

    // ====== ì‹œì‘ ======
    updateHud();
    resizeAll();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
